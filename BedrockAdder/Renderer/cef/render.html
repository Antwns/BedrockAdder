<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>BA Render</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            background: transparent;
        }

        canvas {
            display: block;
        }
    </style>
    <script src="https://unpkg.com/three@0.157.0/build/three.min.js"></script>
</head>
<body>
    <script>
        (async function () {
        const url = new URL(window.location.href);
        const size = parseInt(url.searchParams.get('size') || '256', 10);
        const modelPath = url.searchParams.get('modelPath'); // file:///.../model.json
        const texMapB64 = url.searchParams.get('texMap');    // base64(JSON {slot->file:///...png})
        const bgTransparent = (url.searchParams.get('transparent') || '1') === '1';

        const scene = new THREE.Scene();

        // --- ORTHOGRAPHIC CAMERA FOR GUI-STYLE RENDER ---
        // Coordinates of Minecraft models live roughly in [0,16] per axis,
        // with our centering putting them around [-8, +8]. So a 32x32 frustum
        // is plenty for items/blocks.
        const frustumSize = 32;
        const camera = new THREE.OrthographicCamera(
        -frustumSize / 2,   // left
        frustumSize / 2,   // right
        frustumSize / 2,   // top
        -frustumSize / 2,   // bottom
        0.1,
        1000
        );

        // Look straight at the origin along +Z (Three.js default forward is -Z,
        // but we just put the camera at +Z looking at (0,0,0)).
        camera.position.set(0, 0, 64);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: bgTransparent });
        renderer.setPixelRatio(1);
        renderer.setSize(size, size);
        renderer.setClearAlpha(bgTransparent ? 0 : 1);
        document.body.appendChild(renderer.domElement);

        const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.1);
        hemi.position.set(0, 50, 0);
        scene.add(hemi);

        const dir = new THREE.DirectionalLight(0xffffff, 0.8);
        dir.position.set(30, 50, 40);
        scene.add(dir);

        function parseB64Json(b64) {
        try { return JSON.parse(atob(b64 || "")); } catch { return {}; }
        }

        function loadTexture(urlStr) {
        return new Promise((resolve) => {
        const loader = new THREE.TextureLoader();
        loader.load(
        urlStr,
        tex => {
        tex.flipY = false;
        resolve(tex);
        },
        undefined,
        () => resolve(null)
        );
        });
        }

        async function loadTextureDictionary(map) {
        const result = {};
        const entries = Object.entries(map || {});
        for (const [slot, uri] of entries) {
        if (!uri) continue;
        result[slot] = await loadTexture(uri);
        }
        return result;
        }

        function boxGeomFromElement(el) {
        const f = el.from, t = el.to;
        const w = (t[0] - f[0]);
        const h = (t[1] - f[1]);
        const d = (t[2] - f[2]);
        const geom = new THREE.BoxGeometry(w, h, d);

        // Center the element in [-8, +8] on all axes (no Y flip, MC-style)
        const cx = (f[0] + t[0]) / 2 - 8;
        const cy = (f[1] + t[1]) / 2 - 8;
        const cz = (f[2] + t[2]) / 2 - 8;
        geom.translate(cx, cy, cz);
        return geom;
        }

        function faceNameOrder() {
        return ["east", "west", "up", "down", "south", "north"];
        }

        // Flag to distinguish atlas-based models (3D items) vs our simple cuboid blocks
        let modelHasTextureAtlas = false;

        // Apply UVs from the model JSON only when we have a texture atlas (3D items)
        function applyFaceUVs(geom, group, face, texture) {
        if (!modelHasTextureAtlas) {
        // Blocks / simple cuboids: rely on BoxGeometry's built-in UVs
        return;
        }

        if (!geom || !group) return;
        const uvAttr = geom.attributes.uv;
        if (!uvAttr) return;

        if (!face || !face.uv || face.uv.length < 4) return;

        const tex = texture || null;
        const texW = tex && tex.image && tex.image.width ? tex.image.width : 16;
        const texH = tex && tex.image && tex.image.height ? tex.image.height : 16;

        const uv = face.uv;
        const u1 = uv[0] / texW;
        const v1 = uv[1] / texH;
        const u2 = uv[2] / texW;
        const v2 = uv[3] / texH;

        // BoxGeometry in r157 is non-indexed by default:
        // - groups operate on vertices, not indices
        // - each face group has 6 vertices (2 triangles) => 12 UV floats
        const start = group.start * 2;

        const rect = [
        // first triangle
        u2, v1,
        u1, v1,
        u2, v2,
        // second triangle
        u1, v1,
        u1, v2,
        u2, v2
        ];

        for (let i = 0; i < rect.length && (start + i) < uvAttr.array.length; i++) {
        uvAttr.array[start + i] = rect[i];
        }

        uvAttr.needsUpdate = true;
        }

        function sanitizeSlotName(slot) {
        if (typeof slot !== "string") return "";
        return slot.startsWith("#") ? slot.substring(1) : slot;
        }

        // Apply ONLY the display.gui transform from the model.
        // No extra adjX/adjY/adjZ, no axis sign hacks.
        function applyDisplayTransform(group, displayRoot) {
        if (!displayRoot) return;
        const gui = displayRoot.gui || displayRoot.GUI || null;
        if (!gui) return;

        const rot = Array.isArray(gui.rotation) ? gui.rotation :
        Array.isArray(gui.Rotation) ? gui.Rotation : null;
        const trans = Array.isArray(gui.translation) ? gui.translation :
        Array.isArray(gui.Translation) ? gui.Translation : null;
        const scale = Array.isArray(gui.scale) ? gui.scale :
        Array.isArray(gui.Scale) ? gui.Scale : null;

        if (rot && rot.length === 3) {
        // Direct mapping from Blockbench/Minecraft rotations:
        // [x, y, z] degrees → Three.js Euler (XYZ order) in radians.
        group.rotation.set(
        THREE.MathUtils.degToRad(rot[0]),
        THREE.MathUtils.degToRad(rot[1]),
        THREE.MathUtils.degToRad(rot[2])
        );
        }

        if (trans && trans.length === 3) {
        group.position.set(trans[0] / 16, trans[1] / 16, trans[2] / 16);
        }

        if (scale && scale.length === 3) {
        group.scale.set(scale[0], scale[1], scale[2]);
        }
        }

        try {
        const response = await fetch(modelPath);
        const model = await response.json();

        // Detect atlas-based models (like your 3D grenade) vs plain cuboid
        modelHasTextureAtlas = !!(model.textures && Object.keys(model.textures).length > 0);

        const texMap = parseB64Json(texMapB64);
        const textures = await loadTextureDictionary(texMap);
        const fallbackTexture = Object.values(textures).find(t => t) || null;

        const materialCache = new Map();
        const materials = [];

        function materialIndexFor(slotName) {
        const slot = sanitizeSlotName(slotName);
        const tex = (slot && textures[slot]) || fallbackTexture;
        const key = tex ? tex.uuid : "__flat__";

        if (!materialCache.has(key)) {
        const mat = new THREE.MeshStandardMaterial({
        map: tex || null,
        transparent: true,
        roughness: 0.8,
        metalness: 0.0
        });
        materialCache.set(key, materials.length);
        materials.push(mat);
        }

        return materialCache.get(key);
        }

        const rootGroup = new THREE.Group();
        const elements = model.elements || [];
        const order = faceNameOrder();

        elements.forEach(el => {
        const geom = boxGeomFromElement(el);
        const faces = el.faces || {};
        const groups = geom.groups || [];

        for (let g = 0; g < Math.min(groups.length, order.length); g++) {
        const faceName = order[g];
        const face = faces[faceName] || null;
        const slotName = face && face.texture ? face.texture : null;
        const matIndex = materialIndexFor(slotName);
        if (groups[g]) {
        groups[g].materialIndex = matIndex;
        }
        const slot = sanitizeSlotName(slotName);
        const tex = (slot && textures[slot]) || fallbackTexture;
        applyFaceUVs(geom, groups[g], face, tex);
        }

        const mesh = new THREE.Mesh(geom, materials);

        if (el.rotation) {
        const axis = el.rotation.axis || "y";
        const angle = (el.rotation.angle || 0) * Math.PI / 180;
        if (axis === "x") mesh.rotateX(angle);
        else if (axis === "y") mesh.rotateY(angle);
        else if (axis === "z") mesh.rotateZ(angle);
        }

        rootGroup.add(mesh);
        });

        // Apply ONLY model.display.gui transform; if missing, we leave rootGroup as-is.
        applyDisplayTransform(rootGroup, model.display);

        scene.add(rootGroup);

        // Render once
        renderer.render(scene, camera);

        if (typeof renderer.dispose === "function") {
        renderer.dispose();
        }

        window.renderDone = true;
        } catch (e) {
        console.error(e);
        window.renderDone = true;
        }
        })();
    </script>
</body>
</html>